xhr(XMLHttpRequest)：中的open属性xhr.open('get','/user/get-xhr-server',true)第二个参数是指的浏览器路由，而不是磁盘路径，通过路由来调取函数，true是指页面采用异步方式获得

AJAX 的 open 方法主要用于初始化请求并配置相关参数，其核心作用是建立与服务器的异步通信连接，通过open指向指定路由并再之后的操作调用视图函数

‌文本数据处理‌：当服务器响应为纯文本或简单字符串时，使用responseText直接获取原始文本内容。
xhr.responseText，获取对应路由的视图函数的 Httpresponse对象 返回的纯文本数据
浏览器数据请求的本质就是从路由(字符串)上通过标识字符分割并截取信息例如：'/user/get-xhr-server/?uname=' + uname(一个变量)
从这个GET.get('uname')就是路由当中截取到的uname(变量代表的实际值)

request.GET/POST的只是一个类字典的扩展对象，可以使用字典的所有内容，但实际上不是字典。

html网页一般是从上而下渲染，所以script一般写最后面，从而再执行函数的时候得到html页面中的数据，而jq则是默认在最后拿取数据，最后执行函数123


Content-Type:application/x-www-form-urlencoded ，此处的请求头是django判断是否为form表单提交的关键，只有当 值 如前时才能被django识别为表单提交，若其他的请求头不是，则要进行设置，比如ajax
request.post是针对于post提交的表单数据进行提取

‌请求头‌由客户端发送至服务器，主要用于描述客户端的请求需求（如Accept、Cookie、User-Agent等），帮助服务器理解客户端的意图。 ‌
1
2
‌响应头‌由服务器发送至客户端，包含Content-Type、状态码、缓存控制指令等信息，指导客户端处理响应数据。

在ajax中的open方法第三个属性设置
：当为true时是异步请求，false是同步请求
当为异步请求时由于程序比浏览器页面的请求快，所以可能会导致再执行回调函数(页面请求)时还未执行，整个程序已经执行完毕，从而使得结果错误
例如：if(xhr.readyState===4&&xhr.status===200){
                if (xhr.responseText){
                    ret=true
当程序结束时如果请求状态还没有进行到4阶段，那么便不会给ret赋值为true

当用json格式响应给浏览器的时候应该修改响应头，content_type='application/json'，
例如return HttpResponse(json_str_array,content_type='application/json')

# sort_keys = True  让输出的json串有序排列(按需求，不一定都用)
    例如:json_str=json.dumps(dic,sort_keys=True)
    
由于json转化的字符串会使键和值之间多一个无用的空格，所以为优化使用separators=(',',':')来删掉，','指的是 每一个键值对 之间用 , 隔开。':' 指的是 键与值 用 : 分隔
用法：json_str=json.dumps(dic,sort_keys=True,separators=(',',':'))

from django.core import serializers:从django框架中引用的json字符串转换方法转换后的结果有太多冗余，并不推荐使用 ，会造成大量的资源浪费
JsonResponse(s)可以直接转化为字符串，但是只能转化字典，即用{}包裹的

反序列化：将字符串转化为json对象
序列化：将json对象转化为字符串

STATICFILES_DIRS 的作用是在 Django 项目中指定额外的静态文件目录，用于存放项目的公共静态资源（如 CSS、JavaScript、图片等）。它的主要功能是告诉 Django 在默认的 app/static 目录之外，还需要从哪些路径中查找静态文件。

load函数可以继承别的页面内容，例如：$('#show').load('/ajax/load_test_server/ #btn2') # 继承/ajax/load_test_server/路由下视图函数返回的页面内容 #btn2：只继承id=btn2的部分,load再默认不传参的时候是get请求

Content-Type 是 HTTP 响应头中用于指明返回数据的媒体类型（MIME 类型）的字段。它告诉客户端如何解析和处理服务器返回的数据。以下是一些常见的 Content-Type 类型及其用途：

	text/html：HTML 文档。
	text/css：CSS 样式表。
	text/javascript 或 application/javascript：JavaScript 脚本。
	2. 应用类型
	application/json：JSON 格式数据，常用于 API。
	application/xml：XML 格式数据。
	application/pdf：PDF 文件。
	application/octet-stream：二进制数据流，常用于文件下载。
	application/x-www-form-urlencoded：表单数据编码格式，常用于 POST 请求。
	3. 图像类型
	image/png：PNG 图片。
	image/jpeg：JPEG 图片。
	image/gif：GIF 图片。
	image/svg+xml：SVG 矢量图。
	4. 音视频类型
	audio/mpeg：MP3 音频。
	audio/ogg：OGG 音频。
	video/mp4：MP4 视频。
	video/webm：WebM 视频。
	5. 特殊类型
	multipart/form-data：多部分数据，常用于文件上传。
	application/zip：ZIP 压缩文件。
	application/vnd.ms-excel：Excel 文件。
	
	application/vnd.openxmlformats-	officedocument.wordprocessingml.document：Word 文档（.docx）
	
a={name:'aaaa'} js中的语法，name是一个字符串，相当于'name'
而在python中name是一个变量可以赋值，要在赋值后再用
再json中的语法为a={'name':'aaaa'},并且再js中最后会变回a={name:'aaaa'}，即符合js语法规范的形式，js支持json语法，但不会被json改变自身

浏览器中get请求无请求头，而post请求一定有请求头，content-type
响应头中一定有Content-type

json.dumps() 的作用是将 Python 对象（如字典、列表等）序列化为 JSON 格式的字符串,即 键，字符串 用双引号(必须)括起，元组变成列表，列表和字典外层括号不变
$.get(url,data,callback(data),type):第二个data是像服务端发送的数据，回调函数callback的data是服务端httpresponse对象返回的数据，type是数据格式

JSON.parse() 方法可以将一个 JSON 字符串 转换为 JavaScript 对象。
// JSON 字符串
const jsonString = '{"name": "Alice", "age": 25, "isStudent":false}';
// 使用 JSON.parse() 将 JSON 字符串转换为js对象

const jsonObject = JSON.parse(jsonString);
console.log(jsonObject);

// 输出: { name: 'Alice', age: 25, isStudent: false }
console.log(jsonObject.name); // 输出: Alice

csrf验证在post申请时浏览器客户端提交到服务端时要将这个键值对一起提交给服务端，否则导致403页面

$.ajax()函数中的beforesend属性：浏览器在向服务器发送请求之前可以再其中进行对请求信息的验证，若不符合要求可以中断请求，该属性中执行的函数几乎与发请求的时间同步，因此面对一些带有时效性的数据适合在这里创建(再其他函数创建的 数据创建后还需要执行一些函数和功能，处理这些逻辑和功能仍需要时间，甚至发生阻塞从而导致数据再发送请求前过期失效)

ajax上传数据两个路由：一个路由的视图函数用来返回模板页面和其中的js逻辑代码，另一个路由的视图函数用来处理数据和

表格行本来是从上向下显示的。但是，应用了thead/tbody/tfoot以后，就“从头到脚”显示，不管你的行代码顺序如何。也就是说如果thead写在了tbody的后面，html显示时，还是以先thead后tbody显示。

js在跨域请求中视图函数里的Httpresponse返回对象后面要加content_type='text/javascript'，
例如:return HttpResponse(func+"('我夸出来了')",content_type='text/javascript')

跨域请求是只在当前的域名下请求其他域名的网页
跨域特性：<script> 标签的 src 可访问任何域的资源，无需 CORS（跨域资源共享）支持。
JSONP 只能使用 GET 请求（因为 <script> 加载本质上是 GET），且需要前后端协同定义回调函数名
数据传输：服务器返回格式如 callbackFunction(data)，其中 data 是 JSON 数据对象。

自动执行特性：浏览器遇到 <script> 标签时，无论其内容是内联还是外部资源，都会立即下载并执行其中的 JavaScript 代码。这是 HTML 规范的标准行为。

无同源限制：浏览器允许通过 <script> 标签加载任意域的外部脚本，不受同源策略限制（安全策略仅作用于脚本执行后的 DOM 操作）。jquery版本发出的请求还会发一个时间戳：例如
http://localhost:8000/ajax/cross_server/callback=print&callback=print&_=1757762682667  #_=1757762682667就是时间戳12

single page web application,简称SPWA,单页面渲染应用，只在一个页面上渲染加载新内容，

site:域名     ：检查网页收录量，例如：site:www.baidu.com 

Base64是一种使用64个可打印字符（包括大小写字母、数字及符号）对二进制数据进行编码的方法，广泛应用于数据传输和存储。 ‌

Base64编码原理(有对应的编码解码表)：以三个字节为一组
先将数据转变为asc2编码中对应序号的二进制(8位，若没有则补0)，然后将共24为二进制分为六位一组共四组，再将六位(不足六位后面补0)转换成对应的十进制，最后再base64的表里面找到最终加密后的数据，剩下的不够四位字符的地方全部用=代替
Base64将3个字节的二进制数据转换为4个Base64字符（每个字符对应6位二进制数据）。不足3字节时，末尾用=符号填充以确保长度正确。

python中dic(字典)和set(集合)的哈希运算原理：在笔记的项目中有图



哈希表的基础知识:（哈希运算是一种散算法）
    哈希表通常由两部分组成：哈希函数和存储区域。哈希函数用于计算关键字的位置索引，它将关键字转换为一个索引，该索引指向数据在哈希表中的位置。而存储区域则用于存放数据。
    哈希表的存储机制可以形象地看作是一个大的数组，每个位置称为“槽（slot）”，其中存储着数据。理想情况下，哈希函数能保证每个关键字都能映射到唯一的槽位，但在实际应用中往往会发生冲突。
    
    链地址法中，哈希表的每个槽位对应一个链表，链表的节点通常由键值对组成。链地址法的解决策略是将所有冲突的数据项存储在一个链表中。每个哈希表的位置都维护一个链表，所有键值对根据哈希值存储在此链表中。链地址法的缺点主要在于它增加了额外的内存开销，因为每个槽位都需要额外的指针来维护链表。此外，链表操作的时间复杂度为O(n)，在极端情况下，性能可能会下降，尤其是当很多元素都冲突在一个槽位上时。(一般一个槽位只有一个键值对，此处则是多添加了一个链表)
    
    哈希表的设计主要是为了在内存中快速查找数据，其查找时间复杂度为O(1)。设计一个高效的哈希表，关键在于控制哈希表的长度、设计哈希函数以及处理哈希冲突。
    哈希表长度的选择
	哈希表的长度一般是定长的。在存储数据之前，我们需要知道数据的规模，以避免频繁扩容。如果哈希表设计得太大，会浪费空间；如果设计得太小，则容易发生哈希冲突，影响效率。
    使用素数作为哈希表长度
	选择素数作为哈希表的长度，可以减少哈希冲突的概率。因为当一个数除以素数时，会产生最分散的余数。例如，哈希表长度为97（素数）时，输入数据为一系列以100为因子的数列，发生碰撞的概率较低。
    装填因子
	装填因子（负载因子）是哈希表中已使用的空间与总空间的比值。装填因子越小，冲突的机会越小，但空间浪费也越大。通常，装填因子控制在0.7-0.8之间，可以保证哈希表的平均查找长度为O(1)。
    动态扩容
	对于数据量不确定的应用，最好设计动态可变尺寸的哈希表。当哈希表尺寸太小时，可以将哈希表尺寸扩大一倍。


哈希函数将输入（例如键或元素）转换为数组索引，使得每个键或元素都能映射到数组的一个位置上。理想的哈希函数应该尽可能均匀地分布所有的输入到数组的每个位置，以减少冲突（即两个不同的键产生相同的哈希值）。
Python的字典使用哈希表来实现，具体来说：
	键：每个键通过哈希函数映射到一个索引位置。
	值：与键相关联的值存储在对应的索引位置。
	冲突处理：通常使用链地址法解决冲突，即每个数组位置可以存储一个链表，链表中存储具有相同哈希值的键值对。
	
	计算出的哈希值是一个非常大的整数。为了将这个哈希值映射到一个有限的索引位置上，我们通常使用模运算（%）将哈希值与哈希表的大小（即桶的数量）进行取模运算。例如，如果哈希表有100个桶，则每个键的哈希值通过hash_value % 100来计算其对应的索引位置。
	
当字典中的元素数量超过其当前容量的一定比例时（例如Python中的默认是2/3），字典会自动扩容并重新哈希其内容到新的更大的数组中，以保持操作的效率。

python解决冲突的方法基于当前位置进行二次哈希运算：
    在处理哈希冲突时，可以使用二次哈希（quadratic probing）来解决。这种方法的基本思想是，当发生冲突时，不是简单地尝试下一个位置，而是根据一个二次函数来选择下一个位置。具体步骤如下：

    计算初始索引：首先，使用哈希函数计算键的初始索引。
    处理冲突：如果该索引已被占用，则计算下一个可能的索引位置，通常是 (原始索引 + 1^2) % 数组大小，然后是 (原始索引 + 2^2) % 数组大小，依此类推。而在作作删除的时候会因为第二次的索引位置是基于第一次生成的 只作伪删除，以便寻找进行了二次哈希的索引。如何寻找第二个索引则是通过上面所说的链地址法，
    例如，如果数组大小为10，并且原始索引为5，那么下一个可能的索引将是：
	6 (5 + 1^2)
	9 (5 + 2^2)
	4 (5 + 3^2)


O() 通常用于描述算法的时间复杂度或空间复杂度。
O(1)无论数据规模多大，都能在一次计算后找到目标。哈希算法在理想情况下就是 O(1)
O(n) 表示算法的复杂度与输入数据规模成线性关系。数据规模增大几倍，耗时也增大几倍。例如，遍历一个数组的操作就是 O(n)。后续以此类推

在web端中/和+是敏感字符，因为在搜索栏中会根据这两个字符去寻找数据，所以在进行base64加密的时候要用urlsafe_b64encode(header_json)

deepcopy 会递归创建嵌套结构中所有对象的新实例，实现对象图的完全解耦：
	original = {"a": [1,2], "b": {"c": 3}}
	copied = copy.deepcopy(original)
	# 修改副本不影响原始对象
	copied["a"].append(3)  
	copied["b"]["c"] = 99
	print(original)  # 输出: {'a': [1, 2], 'b': {'c': 3}} → 原始数据未污染
	
data = {"items": [[1,2], [3,4]]}

普通的赋值，二者本身指向的都是同一个列表或字典(嵌套结构)，修改其中一个都可以改变另一个的值，普通的赋值则不变
a=[1,2,3,[4,5,6,[7,8]]]   
b=a
c=[1,2,3,4,5,6]
d=c
b[0]=5
d[0]='p'
e=5
f=e
f=6
print('a:'+str(a))      #a:[5, 2, 3, [4, 5, 6, [7, 8]]]
print('b:'+str(b))      #b:[5, 2, 3, [4, 5, 6, [7, 8]]]
print('c:'+str(c))      #c:['p', 2, 3, 4, 5, 6]
print('d:'+str(d))	#d:['p', 2, 3, 4, 5, 6]
print('e:'+str(e))	#e:5
print('f:'+str(f))	#f:5

# 浅拷贝示例
"浅拷贝只复制顶层引用"的含义是：浅拷贝会创建一个新对象，但仅复制原始对象中的顶级元素的引用，而不递归复制嵌套对象的内容。(即只复制除了第一层数据中除了字典和列表的所有数据(等其余嵌套结构))，如果对除嵌套结构以外的顶级元素进行修改则不影响原始数据，若对嵌套结构进行修改则会污染原始数据

a=[1,2,3,[4,5,6,[7,8]]]
b=a.copy()
b[0]=5
b[3][2]=555

print('a:'+str(a))  #a:[1, 2, 3, [4, 5, 555, [7, 8]]]  由于顶级引用被复制所以不改变
print('b:'+str(b))  #b:[5, 2, 3, [4, 5, 555, [7, 8]]]  嵌套结构索引未被复制所以会一起改变

Python中的字典和集合是无序的数据结构，这意味着它们不保留元素插入的顺序。 这是因为Python的字典和集合底层使用了哈希表来实现。 哈希表是一种高效的数据结构，它能够提供快速的查找和插入操作，但它不保留元素的顺序。 哈希表是由一系列的存储桶（buckets）组成的，每个存储桶可以存储一个或多个键值对。
      
散列算法（Hash Algorithm）是一种将任意长度的输入数据转换为固定长度输出的算法，输出的结果称为散列值（或哈希值），常用于数据验证、加密及快速查找

decode()的algorithms必须是字符串列表类型（即使只有一个算法）
      正确示例:jwt.decode(a,'123456',algorithms=['HS256'])
      
在使用pip命令安装 包 的时候会让该包的依赖包自动升级成符合这个包的版本，然而有些地方在作项目的时侯版本已经确定，所以可能会导致因为版本问题无法运行

    

  

