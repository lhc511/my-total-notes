我们先来看一个需求:有一个对象,我们希望监听这个对象中的属性被设置或扶取的过程
■ 通过我们前面所学的知识,能不能做到这一点呢?
□其实是可以的,我们可以通过之前的属性描述符中的存储属性描述符来做到;

在ES6中,新增了一个Proxy类这个类从名字就可以看出来,是用于帮助我们创建一个代理的:
口也就是说,如果我们希望监听一个对象的相关操作,那么我们可以先创建一个代理对象(Proxy对象);
□之后对该对象的所有操作,都通过代理对象来完成,代理对象可以监听我们想要对原对象进行哪些操作

我们可以将上面的案例用Proxy来实现一次:
口首先,我们需要new Proxy对象,并且传入需要侦听的对象以及一个处理对象,可以称之为handler;
    const p = new Proxy(target, handler)
口其次,我们之后的操作都是直接对Proxy的操作,而不是原有的对象,因为我们需要在handler里面进行侦听;

如果我们想要侦听某些具体的操作,那么就可以在handler中添加对应的捕捉器(Trap):
    ■set和get分别对应的是函数类型;
    □set函数有四个参数:
    √ target:目标对象(侦听的对象);   √property:将被设置的属性key;
    √ value:新属性值;              √ receiver:调用的代理对象;
    □get函数有三个参数:
    √target:目标对象(侦听的对象);
    √property:被获取的属性key;
    √receiver:调用的代理对象;

■ 13个活捉器分别是做什么的呢?
handler.getPrototypeOf()    获取原型时触发
    □ Object.getPrototypeOf 方法的捕捉器。
handler.setPrototypeOf()    设置原型时触发
    □ Object.setPrototypeOf方法的捕捉器。
handler.isExtensible()      判断对象是否能够扩展()时触发
    □ Object.isExtensible 方法的捕捉器。
handler.preventExtensions()  阻止对象扩展()时触发
    □ Object.preventExtensions 方法的捕捉器。
handler.getOwnPropertyDescriptor()    获取属性描述符触发
    □ Object.getOwnPropertyDescriptor 方法的捕捉器。
handler.defineProperty()       定义属性描述符时监听
    □ Object.defineProperty 方法的捕捉器。
handler.ownKeys()□ Object.getOwnPropertyNames 方法和Object.getOwnPropertySymbols 方法的捕捉器。
handler.has()：□ in操作符的捕捉器。
handler.get()：属性读取操作的捕捉器。
handler.set()：□ 属性设置操作的捕捉器。
handler.deleteProperty()：□ delete 操作符的捕捉器。
handler.apply()：函数调用操作的捕捉器。
handler.construct()：new 操作符的捕捉器。

■ Reflect也是ES6新增的一个API,它是一个对象,字面的意思是反射。
■ 那么这个Reflect有什么用呢?
□ 它主要提供了很多操作JavaScript对象的方法,有点像Object中操作对象的方法;
□ 比如Reflect.getPrototypeOf(target)类似于Object.getPrototypeOf();
□ 比如Reflect.defineProperty(target,propertyKey,attributes)类似于Object.defineProperty();

■ 如果我们有Object可以做这些操作,那么为什么还需要有Reflect这样的新增对象呢?
□ 这是因为在早期的ECMA规范中没有考虑到这种对 对象本身的操作如何设计会更加规范,所以将这些API放到了Object上面;
□ 但是Object作为一个构造函数,这些操作实际上放到它身上并不合适;
□ 另外还包含一些类似于in、delete操作符,让JS看起来是会有一些奇怪的;
□所以在ES6中新增了Reflect,让我们这些操作都集中到了Reflect对象上;
reflect在设置后会返回布尔类型来表示成功和失败,可以在此基础上再做一些事情
■ 那么Object和Reflect对象之间的API关系,可以参考MDN文档:
    https://developer.mozilla.org/zh-
    CN/docs/Web/JavaScript/Reference/Global Objects/Reflect/Comparing Reflect and Object methods

Reflect.get的隐式行为
Reflect.get(target, propertyKey [, receiver])方法用于获取对象上某个属性的值。它有三个参数：
target：目标对象;  Key：对象的目标属性/键 ;  receiver（可选）：如果遇到访问器属性，则作为this的值
当receiver参数被省略时：
如果目标属性是访问器属性（getter），则getter函数中的this将绑定到target（目标对象本身）。
如果目标属性是普通数据属性，则直接返回该属性的值。
当receiver参数被提供时：
如果目标属性是访问器属性，则getter函数中的this将绑定到receiver对象。
如果目标属性是普通数据属性，则行为与省略receiver时相同（直接返回值）。

1. receiver 的基本概念
receiver 是 JavaScript 中 Proxy 和 Reflect API 的一个参数，用于指定方法执行时的 this 上下文（即函数内部的 this 值）。
在 Proxy 的捕获器（trap，如 get、set）中，receiver 表示最初调用该操作的对象，通常是代理对象本身。这解决了原对象（target）方法调用时 this 意外绑定到原始对象的问题。
在 Reflect 方法中，receiver 作为可选参数传入，用于显式设置 this 值，使对象操作更一致和可靠。
核心好处：提供对代理对象行为的精细控制，增强代码封装性和复用性，避免常见陷阱如递归调用或 this 绑定错误

当有捕获器时通过捕获器调用访问属性，当没有捕获器时直接访问属性
我们正在讨论的是使用Proxy代理对象时，原对象有getter/setter访问器属性时，打印操作会执行两次，而没有时只执行一次的现象
1. 原对象是普通数据属性
示例代码：
const obj = {
    _name: '张三',  // 普通数据属性
    phone: '1321111111',
    age: 20
};
const proxy = new Proxy(obj, {
    get(target, key, receiver) {
        console.log('get:', key); // 打印访问的键    get: _name
        return Reflect.get(target, key, receiver);
    }
});
// 访问代理对象的属性
console.log(proxy._name);  //张三
原因：当访问proxy._name时，代理的get捕获器被触发一次，然后通过Reflect.get获取obj._name的值。


原对象有访问器属性
示例代码：
const obj = {
    _name: '张三',
    get name() {          // 访问器属性
        return this._name;
    },
    set name(val) {
        this._name = val;
    }
};

const proxy = new Proxy(obj, {
    get(target, key, receiver) {
        console.log('get:', key);
        return Reflect.get(target, key, receiver);
    }
});

// 访问代理对象的name属性
console.log(proxy.name);

输出：get: name
     get: _name
     张三
原因：这里出现了两次打印，第一次是访问name属性，第二次是访问_name属性。

关键点：this的绑定和receiver参数
在访问器属性（getter/setter）中，this的值取决于如何调用。当我们通过代理对象访问属性时，如果原对象的访问器方法中使用了this（如this._name），则这个this会指向代理对象（因为receiver参数的作用），而不是原对象。
在代理的get捕获器中，我们使用Reflect.get(target, key, receiver)，其中receiver参数是代理对象本身。
当原对象的getter函数被调用时，其中的this被设置为receiver（即代理对象）。
因此，当getter函数执行return this._name时，实际上是在代理对象上访问_name属性，从而再次触发代理的get捕获器。

详细步骤（原对象有访问器属性时）
访问proxy.name：
代理的get捕获器被触发，key为'name'，打印'get: name'。
执行Reflect.get(target, key, receiver)，即Reflect.get(obj, 'name', proxy)。
由于obj.name是一个getter，所以调用该getter函数，此时getter函数内部的this被设置为receiver（即proxy代理对象）。
在getter函数内执行return this._name，此时相当于访问proxy._name。
再次触发代理的get捕获器，key为'_name'，打印'get: _name'。
执行Reflect.get(target, '_name', receiver)，此时target是obj，key是'_name'，receiver是proxy，但由于obj._name是普通数据属性，直接返回'张三'。
因此，整个过程中，代理的get捕获器被调用了两次：一次是name，一次是_name。

对比：原对象没有访问器属性
当原对象没有访问器属性，而是普通数据属性时，访问proxy.name：
触发代理的get捕获器，打印'get: name'。
执行Reflect.get(target, key, receiver)，此时obj.name是普通属性，直接返回值，不会触发其他访问。

类中属性定义规则
在constructor方法中定义：最常见的方式是在类的constructor中使用this.propertyName = value;语句。这些属性每个实例都独立拥有。
类字段语法（ES2022+）：在类体中直接声明属性，语法为propertyName = value;（无需this关键字）。这简化了代码，避免了constructor中的冗余初始化。
通过类的实例访问，如instance.propertyName。
不能通过类本身直接访问（因为属性绑定到实例）。
class User {
  // 类字段语法定义实例属性（ES2022+）
  name = "Guest"; // 实例属性，默认值
  constructor(age) {
    // 在constructor中定义实例属性
    this.age = age; // 实例属性，通过参数初始化
  }
}

使用static关键字定义：在类体中直接声明，语法为static propertyName = value;（ES2022+标准）。这些属性绑定到类本身，而非实例。
通过类名直接访问，如ClassName.propertyName。
    不能通过实例访问（实例调用会返回undefined）。
    在静态方法中，this指向类自身（而非实例）。
继承规则：
    静态属性被子类继承：子类可以直接访问父类的静态属性。
    如果子类覆盖了静态属性，优先使用子类的定义。
class User {
  static desc = "I'm static"; // 静态属性定义（ES2022+）
  static staticMethod() {
    console.log(this.desc); // this指向User类
  }
}

class Student extends User {} // 子类继承User
console.log(User.desc); // 输出："I'm static"（通过类访问）
User.staticMethod();    // 输出："I'm static"
const user = new User();
console.log(user.desc); // 输出：undefined（不能通过实例访问）
console.log(Student.desc); // 输出："I'm static"（继承自父类）


规则：在类方法内部通过this.property = value定义的属性会绑定到实例对象。
特点：
    属性在方法被调用后才生效
    不同实例的属性互相独立
class User {
  setName(name) {
    this.name = name; // ✅ 正确：定义实例属性
  }
}
const user = new User();
user.setName("John");
console.log(user.name); // 输出："John"

规则：静态方法中this指向类本身，可通过this.prop定义静态属性。
特点：需用static声明方法
属性通过类名访问
示例：
class Config {
  static init() {
    this.apiUrl = "https://api.example.com"; // ✅ 定义静态属性
  }
}
Config.init();
console.log(Config.apiUrl); // 输出URL [^2]

在类方法中使用 this.prop 定义的属性属于实例属性，当同一个对象多次调用该方法时，后续调用会覆盖之前的值。根本原因在于：
通过 this.prop 定义的属性直接绑定到实例对象上
每次调用方法都是操作同一个实例的同一个属性
class Counter {
  setCount(value) {
    this.count = value; // 绑定到实例属性
  }
}
const c = new Counter();
c.setCount(10);
c.setCount(20);
console.log(c.count); // 输出20（覆盖了10）[^1]


■在上面的解决方案中,我们确确实实可以解决请求函数得到结果之后,获取到对应的回调,但是它存在两个主要的问题:
    □第一,我们需要自己来设计回调函数、回调函数的名称、回调函数的使用等;
    口第二,对于不同的人、不同的框架设计出来的方案是不同的,那么我们必须耐心去看别人的源码或者文档,以
    便可以理解它这个函数到底怎么用;

■我们来看一下Promise的API是怎么样的: Promise是一个类
□当我们需要给予调用者一个承诺:待会儿我会给你回调数据时,就可以创建一个Promise的对象;
□在通过new创建Promise对象时,我们需要传入一个回调函数,我们称之为executor
√这个回调函数会被立即执行,并且给传入另外两个回调函数resolve、reject;
√当我们调用resolve回调函数时,会执行Promise对象的then方法传入的回调函数;
√当我们调用reject回调函数时,会执行Promise对象的catch方法传入的回调函数;

const promise = new Promise((resolve, reject) => {
    //·调用resolve,·那么then传入的回调会被执行
    resolve("哈哈哈")
    // 调用reject,那么catch传入的回调会被执行
    reject("错误信息”)
})
promise.then(res => {
    console.log(res)
    }) .catch(err => {
    console.log(err)
})
Promise使用过程
口中待定(pending).初始状态,既没有被兑现,也没有被拒绝
√ 当执行executor中的代码时,处于该状态;即建立的promise对象中传递的函数
□ 已兑现(fulfilled):意味着操作成功完成;
√执行了resolve时,处于该状态;
□ 已拒绝(rejected):意味着操作失败;
√ 执行了reject时,处于该状态;

then方法是Promise对象上的一个方法:它其实是放在Promise的原型上的Promise.prototype.then
promise调用then方法时then中return普通值返回的是一个新的promise对象->见promise对象方法

finally方法
■ finally是在ES9(ES2018)中新增的一个特性:表示无论Promise对象无论变成fulfilled还是rejected状态,最终都会被执行的代码。
■finally方法是不接收参数的,因为无论前面是fulfilled状态,还是rejected状态,它都会执行。

Promise.resolve() 接收一个值作为参数，如果该值本身就是 Promise 对象，则直接返回；如果非 Promise 对象（如普通对象、数值或字符串），它会将其包装成一个已解决的 Promise 对象，结果值即为原始值。
value：可以是任何 JavaScript 值，包括对象、数组、函数或原始类型（如字符串或数字）。

有时候我们已经有一个现成的内容了,希望将其转成Promise来使用,这个时候我们可以使用Promise.resolve方
法来完成。
□ Promise.resolve的用法相当于new Promise,并且执行resolve操作:
    Promise.resolve("why")
//等价于
    new Promise((resolve) => resolve("why"))
■ resolve参数的形态:
    □情况一:参数是一个普通的值或者对象
    □情况二:参数本身是Promise
    □情况三:参数是一个thenable

Promise构造函数的作用：
当我们使用new Promise(executor)时，会创建一个新的Promise对象，该对象处于pending（等待）状态。
构造函数接收一个执行器函数（executor），该函数会立即执行（同步执行）。
执行器函数有两个参数：resolve和reject，它们都是函数。
resolve函数的作用：
当调用resolve(value)时，会将Promise的状态从pending变为fulfilled（已解决），并且将value作为这个Promise的解决值。
在示例中，我们调用resolve({ name: "why" })，因此这个Promise对象的状态变为fulfilled，并且其解决值就是对象{ name: "why" }。
结果：
因此，promise2是一个已经解决（fulfilled）的Promise对象，其值为{ name: "why" }。

promise的类方法->见类方法的js文件
Promise.any() 的功能
核心功能：Promise.any() 方法同样接受一个可迭代对象作为参数。它会等待至少一个 Promise 解决（resolve）；只有当所有 Promise 都拒绝（reject）时，才返回一个拒绝的新 Promise。否则，它会立即解决为第一个解决的 Promise 的值。这使得它特别适合需要“至少一个成功”的场景。
例如，如果传入的 Promise 数组中任何一个解决，则返回的 Promise 立即解决为那个值。
如果所有 Promise 都拒绝，则返回的 Promise 拒绝，原因是一个 AggregateError 对象（包含所有拒绝原因）

核心功能：Promise.race() 方法接受一个可迭代对象（如数组）作为参数，其中包含多个 Promise 实例。
它会“赛跑”这些 Promise：只要其中任意一个 Promise 完成（无论解决 resolve 还是拒绝 reject），就立即返回一个新的 Promise，该 Promise 的状态和值/原因与第一个完成的那个 Promise 相同。这意味着它不等待所有 Promise 完成，而是只关注第一个结果。
例如，如果传入的 Promise 数组中有任何一个解决为值，则返回的 Promise 立即解决为那个值。
如果第一个完成的 Promise 是拒绝的，则返回的 Promise 立即拒绝，并携带那个拒绝原因。