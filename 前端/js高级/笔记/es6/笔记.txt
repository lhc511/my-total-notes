类：
新规中的class类虽然定义书写语法向面向对象的语言靠拢，但其内部机制还是执行的构造函数那一套，不过换了一种写法

类的构造函数
    ■如果我们希望在创建对象的时候给类传递一些参数,这个时候应该如何做呢?
    口每个类都可以有一个自己的构造函数(方法),这个方法的名称是固定的constructor;
    □当我们通过new操作符,操作一个类的时候会调用这个类的构造函数constructor;
    口每个类只能有一个构造函数,如果包含多个构造函数,那么会抛出异常;
    ■当我们通过new关键字操作类的时候,会调用这个constructor函数,并且执行如下操作(与构造函数相同):
    □1.在内存中创建一个新的对象(空对象);
    □2.这个对象内部的[[prototype]]属性会被赋值为该类的prototype属性;
    □3.构造函数内部的this,会指向创建出来的新对象;
    □4.执行构造函数的内部代码(函数体代码);
    □5.如果构造函数没有返回非空对象,则返回创建出来的新对象;

JavaScript class 类中 constructor 的作用:
1. 初始化实例属性
    1.当使用 new 关键字创建类的实例时，constructor 方法会自动调用，用于设置实例的初始状态或属性。例如，定义属性（如变量、对象等）并赋值。
    2.在 constructor 中，通过 this 关键字绑定属性到新创建的实例上。这确保了每个实例拥有自己的独立状态
    3.constructor 允许在对象创建时立即运行一些逻辑，如调用其他方法、验证输入或设置默认值。
    4.如果类中没有显式定义 constructor，JavaScript 会默认添加一个空的 constructor 方法（即 constructor() {}）。这确保了 new 操作能正常工作，但不会执行任何初始化逻辑。
    5.在继承场景中，constructor 可以通过 super() 调用父类的构造函数，确保继承链的正确初始化。如果不调用 super()，子类实例无法创建。
类的继承通过 extends 关键字
class Person{} -> class Student extends Person {}  //此时Students继承了Person类的属性与方法

super关键字
■我们会发现在上面的代码中我使用了一个super关键字,这个super关键字有不同的使用方式:
口注意:在子(派生)类的构造函数中使用this或者返回默认对象之前,必须先通过super调用父类的构造函数!
□ super的使用位置有三个:子类的构造函数、实例方法、静态方法;
    //调用 父对象/父类·的构造函数
    super([arguments]);
    //·调用·父对象/父类 上的方法
    super. functionOnParent([arguments]);

instanceof  □用于检测构造函数的pototype,是否出现在某个实例对象的原型链上。例：
其中构造函数a的pototype出现在了实例对象b的原型链上
var c=function a(){}
const b=new c()
console.log(b.__proto__) //{}
console.log(c.prototype) //{}
console.log(c.prototype===b.__proto__)//true

Object.defineProperty() 是 JavaScript 中用于精确控制对象属性行为的核心方法。例子:

const obj={}
Object.defineProperty(obj, 'x', {
  value: 10,
  writable: false // 不可修改
});
console.log(obj)//{x: 10}

Object.defineProperty(obj, prop, descriptor)
参数	        类型	                作用
obj	        Object	            需要操作的目标对象
prop	    String 或 Symbol	要定义/修改的属性名称
descriptor	Object	            属性描述符对象，用于配置属性的特性（见下表）

Object.create() 用于创建一个新对象，并以指定的对象作为新对象的原型（即设置新对象的 __proto__）。它还可以为新对象添加额外的自身属性（通过属性描述符定义）
语法：Object.create(proto, [propertiesObject])
参数	                 类型	       是否必选	       描述
proto	          Object 或 null     是	       新创建对象的原型对象(即新对象__proto__的指向)。如果为 null，则创建一个没有原型的空对象（如：Object.create(null)）。
propertiesObject	Object	         否	       一个对象，其属性名将作为新对象的属性名，属性值是一个属性描述符对象（类似于 Object.defineProperties() 的第二个参数）。这些属性将被添加到新对象自身（而非原型上）。
例:const obj = Object.create(Object.prototype, {
  name: {
    value: 'Bob',
    writable: true,
    enumerable: true
  },
  age: {
    value: 20,
    enumerable: true
  }});
console.log(obj); // { name: 'Bob', age: 20 }

一个类如果不写extends 继承指定对象。那么默认继承Object
//在JS中类只能有一个父类:单继承，而python支持多继承

“引用”是一个基础概念，指通过别名间接访问变量或对象的机制

// 传统的面向对象多态是有三个前提:
//1>·必须有继承(是多态的前提)    js中看有没有，因为很灵活
//2>·必须有重写(子类重写父类的方法)
//3>·必须有父类引用指向子类对象

■ES6中对 对象字面量 进行了增强,称之为Enhanced object literals(增强对象字面量)。
■字面量的增强主要包括下面几部分:
□属性的简写:Property Shorthand
□方法的简写:Method Shorthand
□计算属性名:Computed Property Names
let-const创建变量

// let-const和window的关系
口作用域提升:在声明变量的作用域中,如果这个变量可以在声明之前被访问,那么我们可以称之为作用域提升;
■所以我的观点是let、const没有进行作用域提升,但是会在执行上下文创建阶段被创建出来。
□这些变量会被创建在包含他们的词法环境被实例化时,但是是不可以访问它们的,直到词法绑定被求值(即在代码执行中被赋值时);

我们知道,在全局通过var来声明一个变量,事实上会在window上添加一个属性:
□但是let、const是不会给window上添加任何属性的。
■那么我们可能会想这个变量是保存在哪里呢?
■我们先回顾一下最新的ECMA标准中对执行上下文的描述
Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the
variable object. For function code, parameters are added as properties of the variable object.
每一个执行上下文会被关联到一个变量环境(variable object,VO),在源代码中的变量和函数声明会被作为属性添加到VO中。
对于函数来说,参数也会被添加到VO中。

Every execution context has an associated VariableEnvironment. Variables and functions declared in ECMAScript code evaluated in an execution
context are added as bindings in that VariableEnvironment's Environment Record. For function code, parameters are also added as bindings to that
Environment Record.

■我们知道,在全局通过var来声明一个变量,事实上会在window上添加一个属性:
□但是let、const是不会给window上添加任何属性的，本质上是创建了另一个对象。 都通过harshmap被保存到了一个叫 VariableMap 东西里
而在修改let、const创建的对象时连windows中的对象会一起修改是为了兼容以前的代码

每一个执行上下文会关联到一个变量环境(VariableEnvironment)即VE中,在执行代码中变量和函数的声明会作为环境记录(Environment Record)添加到变量环境中。
对于函数来说,参数也会被作为环境记录添加到变量环境中。ve和vo类似，也是在函数执行上下文中指向对中的一个对象(存储数据)variables_中，

//暂时性死区  在一个块作用域中定义了一个对象(即使已有同名全局对象)，也无法访问定义的对象
var foo = "foo"
if (true) {console.log(foo);let foo = "abc"//不可访问};
function bar() {console.log(foo);let foo = "abc"//不可访问}
bar()

// 函数参数默认值 和python一样，直接在参数中等号赋值就好
那么剩余参数和arguments有什么区别呢?
    □剩余参数只包含那些没有对应形参的实参,而arguments对象包含了传给函数的所有实参;
    □ arguments对象不是一个真正的数组,而rest参数是一个真正的数组,可以进行数组的所有操作;
    □ arguments是早期的ECMAScript中为了方便去获取所有的参数提供的一个数据结构,而rest参数是ES6中提供
    并且希望以此来替代arguments的;
箭头函数中没有this，和arguments属性，只会去父作用域找，并且不能作为构造函数创建对象
展开运算符其实是浅拷贝
//大的数值的连接符(ES2021·ES12)
const num=10_000_000_000_000_000  //方便阅读
console. log (num) //10000000000000000

Symbol是什么呢?Symbol是ES6中新增的一个基本数据类型,翻译为符号。

■ 那么为什么需要Symbol呢?
□在ES6之前,对象的属性名都是字符串形式,那么很容易造成属性名的冲突;
□比如原来有一个对象,我们希望在其中添加一个新的属性和值,但是我们在不确定它原来内部有什么内容的情况下,
很容易造成冲突,从而覆盖掉它内部的某个属性;
□比如我们前面在讲apply、call、bind实现时,我们有给其中添加一个fn属性,那么如果它内部原来已经有了fn属性了呢?
□比如开发中我们使用混入,那么混入中出现了同名的属性,必然有一个会被覆盖掉;

const obj = { [s1]: "abc", [s2]: "cba" } 使用了 计算属性名（Computed Property Names），这是 ES6 引入的语法特性。
方括号 [] 内的 s1 和 s2 是变量或表达式，它们的值会被计算并转换为字符串（或 Symbol），作为对象的属性名
JavaScript的对象属性名（键）只能是字符串（String）或Symbol类型。如果尝试使用其他类型（如对象、数字或布尔值）作为属性名，JavaScript引擎会自动将其转换为字符串
当对象被用作属性名时，JavaScript会调用该对象的toString()方法来获取字符串表示。
所有JavaScript对象都继承自Object.prototype，其默认toString()方法返回"[object Object]
注意:不能通过.语法获取：
    const s1 = "key1";
    const s2 = "key2";
    const obj = { [s1]: "abc", [s2]: "cba" };
    console.log(obj); // 输出: { key1: "abc", key2: "cba" }
传统写法（固定属性名）：{ name: "why" }，属性名是静态字符串 "name"。
计算属性名：{ [variable]: value }，属性名由变量 variable 的值动态决定。
方括号内可以是任意表达式，非仅限于变量：
const obj = {
  ["key" + 1]: "abc",  // 属性名: "key1"
  [2 * 3]: "cba"       // 属性名: "6" (自动转为字符串)
};
Array.from() 是 JavaScript 中用于将类数组对象或可迭代对象转换为真正数组

for(const item of arrSet){  //和python中的for in类似
    console.log(item)
}

在ES6之前,我们存储数据的结构主要有两种:数组、对象。
□在ES6中新增了另外两种数据结构:Set、Map,以及它们的另外形式WeakSet、WeakMap。
Set是一个新增的数据结构,可以用来保存数据,类似于数组，但是和数组的区别是元素不能重复。
口创建Set我们需要通过Set构造函数(暂时没有字面量创建的方式):

WeakSet中只能存放对象类型,不能存放基本数据类型;
WeakMap的key只能使用对象,不接受其他的类型作为key;

■和Set类似的另外一个数据结构称之为WeakSet,也是内部元素不能重复的数据结构。
■那么和Set有什么区别呢?
□区别一:WeakSet中只能存放对象类型,不能存放基本数据类型;
□区别二:WeakSet对元素的引用是弱引用,如果没有其他引用对某个对象进行引用,那么GC可以对该对象进行回收
//弱引用（用的较少）
// 弱因引用就是 依旧可通过对象去访问属性，但是GC(垃圾回收机制)不认可这种引用，
依旧会对引用对象所在的内存空间进行回收，强引用则不会回收
注意:WeakSet不能遍历
□因为WeakSet只是对对象的弱引用,如果我们遍历获取到其中的元素,那么有可能造成对象不能正常的销毁。
□所以存储到WeakSet中的对象是没办法获取的;

Map是一种有序的键值对集合。
Map的键可以是任何JavaScript值（如数字、字符串、对象、函数等），这与普通对象不同（普通对象的键只能字符串或Symbol）。这避免了键被隐式转换为字符串的问题。
另外一个新增的数据结构是Map,用于存储映射关系。
但是我们可能会想,在之前我们可以使用对象来存储映射关系,他们有什么区别呢?
    口事实上我们对象存储映射关系只能用字符串(ES6新增了Symbol)作为属性名(key);
    口某些情况下我们可能希望通过其他类型作为key,比如对象,这个时候会自动将对象转成字符串来作为key
和Map类型相似的另外一个数据结构称之为WeakMap,也是以键值对的形式存在的。那么和Map有什么区别呢?
    □ 区别一:WeakMap的key只能使用对象,不接受其他的类型作为key;
    □ 区别二:WeakMap的key对对象想的引用是弱引用,如果没有其他引用引用这个对象,那么GC可以回收该对象;


