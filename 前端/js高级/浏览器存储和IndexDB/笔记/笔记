浏览器中的cookie一般是由服务器发送一个setcookie的指令，然后在用户的浏览器上设置cookie数据,用户的客户端将cookie存储起来
，当然自己也可以通过代码设置cookie，不过一般不主动添加cookie，在下次发送请求时会自动将cookie携带过去

■WebStorage主要提供了一种机制,可以让浏览器提供一种比cookie更直观的key、value存储方式:
    □ localStorage:本地存储,提供的是一种永久性的存储方法,在关闭掉网页重新打开时,存储的内容依然保留;
    □ sessionStorage:会话存储,提供的是本次会话的存储,在关闭掉会话时,存储的内容会被清除;

html中 a标签的属性target="_blank"是在点击链接后转向一个新的空白页，新开一个页面，原本是在原页面基础上重新渲染(只看做一次会话)
因此在新空白页面只有localStorage，而在原页面上进行渲染则二者都有。

■localStorage和sessionStorage有什么区别?
    □验证一:关闭网页后重新打开,localStorage会保留,而sessionStorage会被删除;
    口验证二:在页面内实现跳转,localStorage会保留,sessionStorage也会保留;
    □验证三:在页面外实现跳转(打开新的网页),localStorage会保留,sessionStorage不会被保留;

■ Storage有如下的属性和方法:
■属性: □ Storage.length : 只读属性
√返回一个整数,表示存储在Storage对象中的数据项数量;
■方法:
    □ Storage.key():该方法接受一个数值n作为参数,返回存储中的第n个key名称;
    Storage.getItem():该方法接受一个key作为参数,并且返回key对应的value;
    □ Storage.setItem():该方法接受一个key和value,并且将会把key和value添加到存储中。
√如果key存储,则更新其对应的值;
    □ Storage.removeItem():该方法接受一个key作为参数,并把该key从存储中删除;
    □ Storage.clear():该方法的作用是清空存储中的所有key;

什么是IndexDB呢?
    □我们能看到DB这个词,就说明它其实是一种数据库(Database),通常情况下在服务器端比较常见;
    □ 在实际的开发中,大量的数据都是存储在数据库的,客户端主要是请求这些数据并且展示;
    □有时候我们可能会存储一些简单的数据到本地(浏览器中),比如token、用户名、密码、用户信息等,比较少存储大量的数据;
□那么如果确实有大量的数据需要存储,这个时候可以选择使用IndexDB;
    ■ IndexDB是一种底层的API,用于在客户端存储大量的结构化数据。
    □它是一种 事务 型数据库系统,是一种基于JavaScript面向对象数据库,有点类似于NoSQL(非关系型数据库);
            事务:对数据库进行操作的一个操作单元(比如kobe转账的操作kobe -100，why +100，两个任务构成的一次完整的操作是一个单元)
    □ IndexDB本身就是基于事务的,我们只需要指定数据库模式,打开与数据库的连接,然后检索和更新一系列事务即可;//并且indexdb的效率会更高

IndexedDB的数据库操作
■ 我们对数据库的操作要通过事务对象来完成:
    □第一步:通过db获取对应存储的事务db.transaction(存储名称,可写操作);
    □第二步:通过事务获取对应的存储对象 transaction.objectStore(存储名称);
■ 接下来我们就可以进行增删改查操作了:
    □ 新增数据 store.add
□ 查询数据
    √方式一:store.get(key)
    √方式二:通过store.openCursor拿到游标对象
▶在request.onsuccess中获取cursor:event.target.result
    >获取对应的key:cursor.key;
    >获取对应的value:cursor.value;
    >可以通过cursor.continue来继续执行;
    □ 修改数据 cursor.update(value)
    □ 删除数据 cursor.delete()

IndexDB的连接数据库
■第一步:打开indexDB的某一个数据库;
    □通过indexDB.open(数据库名称,数据库版本)方法;
    □如果数据库不存在,那么会创建这个数据;
    □如果数据库已经存在,那么会打开这个数据库;

request.onsuccess的含义与作用
触发时机：当某个特定操作（如打开数据库、读取数据、写入数据等）成功完成时触发
transaction.oncomplete的含义与作用
触发时机：当事务（Transaction）中所有操作全部完成且已提交到数据库时触发
BRequest 采用异步操作方式的原因
IDBRequest 作为 IndexedDB 的核心异步操作接口，其设计基于以下几个关键原因：

1. 避免阻塞主线程（核心原因）13
    数据库操作（尤其是大量数据读写）可能耗时较长
    同步操作会冻结用户界面，导致页面无响应
    异步模型允许浏览器在执行数据库操作时继续处理用户交互
典型耗时操作：
    大型数据集查询（如 getAll()）
    复杂索引扫描（如 openCursor()）
    跨对象存储事务操作

IDBTransaction（事务）
    功能：管理数据库操作的原子性单元，确保操作要么全部成功要么全部回滚
    关键特性：隔离级别：readonly（只读）, readwrite（读写）, versionchange（结构变更）
            事件监听：oncomplete, onerror, onabort
IDBObjectStore（对象存储）
    功能：数据库中的核心数据容器，相当于传统数据库的"表"1
    核心操作：数据增删改查（add(), put(), delete(), get()）
            索引创建（createIndex()）
            范围查询（getAll(IDBKeyRange.lowerBound(x))）
IDBRequest（请求对象）
    功能：所有异步操作的载体，承载操作结果或错误
    生命周期：由IDBObjectStore的方法创建（如store.get(key)）
典型工作流：
    通过IDBTransaction获取IDBObjectStore实例
    在对象存储上执行操作，生成IDBRequest
    请求完成后，根据结果更新事务状态3

const transaction = db.transaction(["users"], "readwrite")
、这行代码在 IndexedDB 中创建了一个事务（transaction），是操作数据库的核心步骤。以下是分步解析：

db：             表示已打开的数据库实例（通过 indexedDB.open() 成功获取）
.transaction()： 数据库对象的方法，用于创建事务
                 作用：将后续操作打包成原子操作（要么全部成功，要么全部回滚）
["users"]：      指定事务操作的对象存储（ObjectStore）
                 数组形式允许同时操作多个存储（如 ["users", "orders"]）
"readwrite"：    事务模式（重要参数）： readonly：仅读取（默认） readwrite：允许增删改数据（如 add/put/delete）24
                                   versionchange：修改数据库结构（如创建存储）

const store = transaction.objectStore("users");
    transaction：已创建的事务对象（通过 db.transaction() 获得）
    .objectStore("users")：调用事务对象的方法
    "users"：目标对象仓库的名称
    store：返回的对象仓库引用，用于后续数据操作

数据库事务与原子操作概念解析
1. 事务（Transaction）
定义：数据库操作的逻辑单元，由一组相关的数据库操作（如增删改查）组成，这些操作要么全部成功执行，要么全部撤销回滚。核心特征（ACID）：
    原子性（Atomicity）：事务中所有操作不可分割，如转账时扣款和入账必须同时成功/失败
    一致性（Consistency）：事务执行前后数据库保持合法状态（如账户余额不为负）
    隔离性（Isolation）：并发事务互不干扰（如转账中途其他查询看到的是旧数据）
    持久性（Durability）：提交后修改永久生效，崩溃不丢失
2. 原子操作（Atomic Operation）
    定义：计算机科学中不可分割的最小操作单元，执行过程不会被中断2。
关键特性：
    全有或全无：操作要么完全执行，要么完全不执行（如CPU的CAS指令）
    无中间状态：不会出现部分执行的情况（如银行转账不会扣款后入账失败）
    并发安全：多线程/多核环境下无需额外锁机制