webpack 在4版本以后要使用webpack，webpack-cli 一起使用

到底什么是模块化、模块化开发呢?
    事实上模块化开发最终的目的是将程序划分成一个个小的结构;
    这个结构中编写属于自己的逻辑代码,有自己的作用域,不会影响到其他的结构;
    这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用;
    也可以通过某种方式,导入另外结构中的变量、函数、对象等;
模块化规范:AMD、CMD、CommonJS等;

我们需要知道CommonJS是一个规范,最初提出来是在浏览器以外的地方使用,并且当时被命名为ServerJS,后来为了
体现它的广泛性,修改为CommonJS,平时我们也会简称为CJS。
    Node是CommonJS在服务器端一个具有代表性的实现;
    Browserify是CommonJS在浏览器中的一种实现;
    webpack打包工具具备对CommonJS的支持和转换;

■所以,Node中对CommonJS进行了支持和实现,让我们在开发node的过程中可以方便的进行模块化开发:
    □在Node中每一个js文件都是一个单独的模块;
    □这个模块中包括CommonJS规范的核心变量:exports、module.exports、require;
    □我们可以使用这些变量来方便的进行模块化开发;

■前面我们提到过模块化的核心是导出和导入,Node中对其进行了实现:
    exports和module.exports可以负责对模块中的内容进行导出;
    require函数可以帮助我们导入其他模块(自定义模块、系统模块、第三方库模块)中的内容;

****************require的规则*****************
■我们现在已经知道,require是一个函数,可以帮助我们引入一个文件(模块)中导出的对象。
■那么,require的查找规则是怎么样的呢?(文档网站)
    https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules all together
这里我总结比较常见的查找规则:导入格式如下:require(X)

情况一:X是一个Node核心模块，比如path、http
    直接返回核心模块，并且停止查找
■情况二:X是以./或 .. /或/(根目录)开头的

弟一步:将X当做一个又件仕对应的目录下登找;
1.如果有后缀名,按照后缀名的格式查找对应的文件
2.如果没有后缀名,会按照如下顺序:
    √1>直接查找文件X
    √2>查找X.js文件
    √3>查找X.json文件
    √4>查找X.node文件
第二步:没有找到对应的文件,将X作为一个目录
    □ 查找目录下面的index文件
    √1>查找X/index.js文件
    √ 2>查找X/index.json文件
    √3>查找X/index.node文件

模块的加载过程
■结论一:模块在被第一次引入时,模块中的js代码会被
■结论二:模块被多次引入时,会缓存,最终只加载(运行)一次
□为什么只会加载运行一次呢?
    □这是因为每个模块对象module都有一个属性:loaded。
    □为false表示还没有加载,为true表示已经加载;
■结论三:如果有循环引入,那么加载顺序是什么?
■如果出现右图模块的引用关系,那么加载顺序是什么呢?
    □这个其实是一种数据结构:图结构;
    □图结构在遍历的过程中,有深度优先搜索(DFS,depth first search)和广度优先搜索(BFS,breadth first search);
    □ Node采用的是深度优先算法:main ->aaa->ccc->ddd->eee ->bbb

若模块之间彼此调用浏览器在解析时会出问题，因此出现了AMD(require.js,异步的)，CMD，，ESModule等规范来解决浏览器中对于js文件对于不同模块之间的调用的解析问题
CommonJS规范缺点
■CommonJS加载模块是同步的:
    口同步的意味着只有等到对应的模块加载完毕,当前模块中的内容才能被运行;
    □这个在服务器不会有什么问题,因为服务器加载的js文件都是本地文件,加载速度非常快;
■如果将它应用于浏览器呢?
    □浏览器加载js文件需要先从服务器将文件下载下来,之后再加载运行;
    □那么采用同步的就意味着后续的js代码都无法正常运行,即使是一些简单的DOM操作;
所以在浏览器中,我们通常不使用CommonJS规范:
    □当然在webpack中使用CommonJS是另外一回事;
    □因为它会将我们的代码转成浏览器可以直接执行的代码;

在早期为了可以在浏览器中使用模块化,通常会采用AMD或CMD:
    □ 但是目前一方面现代的浏览器已经支持ES Modules,另一方面借助于webpack等工具可以实现对CommonJS或者ESModule代码的转换;
    □ AMD和CMD已经使用非常少了,所以这里我们进行简单的演练;
    ■ 第一步:下载require.js
    □ 下载地址:https://github.com/requirejs/requirejs
    □ 找到其中的require.js文件;

■第二步:定义HTML的script标签引入require.js和定义入口文件:
□ data-main属性的作用是在加载完src的文件后会加载执行该文件
<script src="./lib/require.js" data-main="./index. js"></script>

■AMD主要是应用于浏览器的一种模块化规范:
    □AMD是Asynchronoys Module Definition(异步模块定义)的缩写;
    □它采用的是异步加载模块;
    □事实上AMD的规范还要早于CommonJS,但是CommonJS目前依然在被使用,而AMD使用的较少了;
我们提到过,规范只是定义代码的应该如何去编写,只有有了具体的实现才能被应用:
□AMD实现的比较常用的库是require.js和curl.js;

■CMD规范也是应用于浏览器的一种模块化规范:
    □CMD 是Common Module Definition(通用模块定义)的缩写;
    口它也采用了异步加载模块,但是它将CommonJS的优点吸收了过来;
    □但是目前CMD使用也非常少了;
    ■CMD也有自己比较优秀的实现方案: SeaJS



///////////////////浏览器加载JS文件的详细过程/////////////////
浏览器加载JS文件的过程可分为下载和加载运行两个核心阶段，具体步骤如下：
1. 下载阶段（从服务器获取文件）
发起请求：当HTML解析器遇到<script>标签时，浏览器立即暂停HTML解析，通过网络线程向服务器发起HTTP/HTTPS请求获取JS文件1。
资源下载：JS文件通过TCP/IP协议从服务器传输到客户端。下载速度受文件大小、网络带宽和服务器响应时间影响。
阻塞特性：
    默认行为：无async/defer属性的同步脚本会阻塞DOM构建，页面呈现暂停直至下载完成3。
    优化方案：使用async（异步下载）或defer（延迟执行）可减少阻塞（见下表对比）。
2. 加载运行阶段（解析与执行）
解析与编译：
    下载完成后，JS引擎（如V8）将JS代码解析为抽象语法树（AST），再编译为字节码或机器码。
执行环境准备：
    创建执行上下文，初始化变量对象、作用域链和this绑定。
代码执行：
    单线程运行：JS在主线程上逐行执行代码。
    阻塞渲染：执行期间暂停GUI渲染线程，防止JS修改DOM导致渲染不一致。
    DOM操作生效：若JS修改DOM/CSS，触发重排（Reflow） 或 重绘（Repaint）。
事件循环机制：
    异步任务（如setTimeout）被推入任务队列，待主线程空闲时按序执行。

阻塞的本质：
    在同步阻塞下载中，当线程发起一个下载请求（如读取网络数据），线程会一直等待直到下载完成。
    期间，线程被操作系统挂起，无法执行其他任务，这称为阻塞。例如，引用[3]指出：“阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。线程阻塞后，不能做其他操作只能等待。”
    这会导致资源浪费和应用程序响应延迟，尤其在UI应用中用户界面会"卡顿"。

异步下载的机制：
    异步下载采用非阻塞方式。线程发起下载请求后，操作立即返回（不等待下载完成），下载过程在后台由操作系统或底层IO系统处理。
    线程可以继续执行其他任务（如处理用户输入或计算）。当下载完成时，通过回调函数、事件或异步通知（如Task.Delay在.NET中的实现）来触发后续处理。

异步编程（如 js 的 async）通过以下机制减少阻塞，核心是将耗时操作与主线程解耦，避免线程因等待资源而挂起
非阻塞等待	       await 将耗时 I/O 操作交由底层系统（如浏览器/Node.js）处理，主线程不被占用4
微任务调度	       异步结果通过微任务队列回调，优先级高于宏任务（如渲染、UI事件）
协程式暂停	       async 函数在 await 处暂停时保存上下文，恢复时无缝接续（类似协程）
隐式 Promise        async 函数自动封装 Promise，无需手动处理 .then() 链式调用
示例代码: // 同步阻塞版本（主线程冻结）
        function syncFetch() {
          const data = synchronousNetworkRequest(); // 假设耗时2秒
          console.log(data); // 2秒内主线程无法响应点击事件
        }

        // async/await 非阻塞版本
        async function asyncFetch() {
          const data = await fetchData(); // 主线程立即释放
          console.log(data); // 数据返回后异步打印
        }
        document.addEventListener("click", () => console.log("点击响应")); // 即使请求中也能触发
////////////////////////////////////////////////////////////////////////////////

ES Module和CommonJS的模块化有一些不同之处:
    口一方面它使用了import和export关键字;
    □另一方面它采用编译期的静态分析,并且也加入了动态引用的方式;
ES Module模块采用export和import关键字来实现模块化:
    □export负责将模块内的内容导出;
    □import负责从其他模块导入内容;
了解:采用ES Module将自动采用严格模式:use strict

<!--  type="module"告诉浏览器加载的是一个模块，使js文件在相互调用也能正常运行  -->
<script src="index.js" type="module"></script>

对于工具库的会有一个同一的出口，即将所有工具函数导入到一个文件中，并且在导入导出时文件的后缀一定要加.js将文件名写完整
出口文件名一般是index.js，导入中的名称要和导出中的名称一致
    默认导出只能有一个
在导入时必须把导入的代码的文件解析完之后才会执行后续的代码

///////////////////ESmodule的解析原理///////////////////////
ES Module的解析流程
■ ES Module是如何被浏览器解析并且让模块之间可以相互引用的呢?
    D https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/
■ ES Module的解析过程可以划分为三个阶段:
        □阶段一:构建(Construction),浏览器根据地址查找js文件,并且下载,将其解析成 模块记录(Module Record一种数据结构);
               浏览器在解析js文件时是静态解析，不会执行文件中的代码，只会分析有没有关键字import，export的语句，而想在执行过程中导入需要import函数
               在请求下载时，由于是从网络请求上下载所以会开启一个本地服务器通过http,https的方式进行下载到浏览器，因此以file开头的本地加载会出错

        □阶段二:实例化(Instantiation),对模块记录进行实例化,并且分配内存空间,解析模块的导入和导出语句,把模块指向对应的内存地址。
            在实例化的时候内部的代码并没有具体运行，因此一些导入和导出的语句其中变量的值是undefined
            import bar from './bar'
            const name = "why"
            const age = 18
            setTimeout(()=>{})
            export { name, age }
            例如在上面名为foo.js文件中的代码，在实例化时只会解析import和export，中间的代码不会运行，所以只解析了变量，并没有解析内容
        □阶段三:运行(Evaluation),运行代码,计算值,并且将值填充到内存地址中;
            在运行后那些导入导出的值才会被实际赋值
当使用webpack时，每次修改文件都要重新打包文件，即在该目录下的终端下执行npx webpack