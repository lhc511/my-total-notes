////////////////////////////////////////迭代器///////////////////////////////////
在 JavaScript/TypeScript 中，Symbol.iterator 是符号值本身，而 [Symbol.iterator] 是使用该符号作为属性名的语法。

所有迭代器都是可迭代对象（迭代器需实现 __iter__() 返回自身）。
但可迭代对象不一定是迭代器（例如列表是可迭代对象，但不是迭代器）

迭代器(iterator),是确使用户可在容器对象(container,例如链表或数组)上遍访的对象,使用该接口无需关心对象的内部实现细节
    □其行为像数据库中的光标,迭代器最早出现在1974年设计的CLU编程语言中;
    □ 在各种编程语言的实现中,迭代器的实现方式各不相同,但是基本都有迭代器,比如Java、Python等;
从迭代器的定义我们可以看出来,迭代器是帮助我们对某个数据结构进行遍历的对象。
在JavaScript中,迭代器也是一个具体的对象,这个对象需要符合迭代器协议(iterator protocol):
    □ 迭代器协议定义了产生一系列值(无论是优先还是无限个)的标准方式
    □那么在js中这个标准就是一个特定的next方法;
next方法有如下的要求
    1个无参数或只有一个参数的函数,返回一个应当拥有以下两个属性的对象:
done ( boolean )
    √如果迭代器可以产生序列中的下一个值,则为false。(这等价于没有指定done这个属性。)
    √如果迭代器已将序列迭代完毕,则为true。这种情况下,value是可选的,如果它依然存在,即为迭代结束之后的默认返回值。
value
    迭代器返回的任何JavaScript值。done 为true时可省略。
*********************************
    迭代器是一个对象
    符合迭代器协议(iterator protocol)
    const iterator = { next: function() { return{ {} }}
*********************************

什么又是可迭代对象呢?
    □它和迭代器是不同的概念:
    口当一个对象实现了iterable protocol协议时,它就是一个可迭代对象;
    口这个对象的要求是必须实现@@iterator方法,在代码中我们使用Symbol.iterator访问该属性;
*********************************
    可迭代对象 是一个对象
    符合可迭代协议(iterable protocol):[Symbol.iterator]函数  //即在对象内实现[Symbol.iterator]的方法
    const iterableObj={[Symbol.iterator]: function(){return 迭代器}
*********************************

原生迭代器对象
■事实上我们平时创建的很多原生对象已经实现了可迭代协议,会生成一个迭代器对象的:
    □String、Array、Map、Set、arguments对象、NodeList集合;

迭代器在某些情况下会在没有完全迭代的情况下中断:  -见js文件6-自定义类的可迭代行
    □比如遍历的过程中通过break、continue、return、throw中断了循环操作;
    □比如在解构的时候,没有解构所有的值;
    ■那么这个时候我们想要监听中断的话,可以添加return方法:

/////////////////////////////////////生成器////////////////////////////////////////////////////////////////
生成器函数执行完毕后一定返回一个生成器对象
生成器本身就是一种特殊的迭代器
生成器是ES6中新增的一种函数控制、使用的方案,它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。
■平时我们会编写很多的函数,这些函数终止的条件通常是返回值或者发生了异常。
■生成器函数也是一个函数,但是和普通的函数有一些区别:
□首先,生成器函数需要在function的后面加一个符号 :*
□其次,生成器函数可以通过yield关键字来控制函数的执行流程:
口最后,生成器函数的返回值是一个Generator(生成器):
√生成器事实上是一种特殊的迭代器;
√ MDN : Instead, they return a special type of iterator, called a Generator.

for(const 变量名 of 可迭代对象){}//此处的变量名代表可迭代对象中的元素，相当于迭代器返回的满足迭代协议的对象中value属性所对应的值
事实上我们还可以使用 yield* 来生产一个可迭代对象:  语法:yield* 可迭代对象
    □这个时候相当于是一种yield的语法糖,只不过会依次迭代这个可迭代对象,每次迭代其中的一个值;

通过生成器名称加括号（例如 genFn()）不能直接执行生成器函数内部的代码。调用生成器函数（如 function* genFn() { ... }）
仅会返回一个生成器对象（iterator object），而不会触发函数体中的代码执行。

////////////////////////////////////////async-await/////////////////////////////////////
有async标志的异步函数若函数内部无特殊标志的代码则与正常函数默认执行流程是一样的
异步函数一定返回一个promise对象

■ async函数另外一个特殊之处就是可以在它内部使用await关键字,而普通函数中是不可以的。
■await关键字有什么特点呢?
□通常使用await是后面会跟上一个表达式,这个表达式会返回一个Promise;
□那么await会等到Promise的状态变成fulfilled状态,之后继续执行异步函数;
■如果await后面是一个普通的值,那么会直接返回这个值;
■如果await后面是一个thenabie的对象,那么会根据对象的then方法调用来决定后续的值;

/////////////////////////进程和线程/////////////////////////////////
线程和进程是操作系统中的两个概念:
□进程(process):计算机已经运行的程序,是操作系统管理程序的一种方式;
□线程(thread):操作系统能够运行运算调度的最小单位,通常情况下它被包含在进程中;
■听起来很抽象,这里还是给出我的解释:
□进程:我们可以认为,启动一个应用程序,就会默认启动一个进程(也可能是多个进程);
□线程:每一个进程中,都会启动至少一个线程用来执行程序中的代码,这个线程被称之为主线程;
口所以我们也可以说进程是线程的容器;

操作系统是如何做到同时让多个进程(边听歌、边写代码、边查阅资料)同时工作呢?
口这是因为CPU的运算速度非常快,它可以快速的在多个进程之间迅速的切换;
□当我们进程中的线程获取到时间片时,就可以快速执行我们编写的代码;
口对于用户来说是感受不到这种快速的切换的;

我们经常会说JavaScript是单线程的,但是JavaScript的线程应该有自己的容器进程:浏览器或者Node。
浏览器是一个进程吗,它里面只有一个线程吗?
    □目前多数的浏览器其实都是多进程的,当我们打开一个tab页面时就会开启一个新的进程,这是为了防止一个页
    面卡死而造成所有页面无法响应,整个浏览器需要强制退出;
    □每个进程中又有很多的线程,其中包括执行JavaScript代码的线程;
JavaScript的代码执行是在一个单独的线程中执行的:
    □这就意味着JavaScript的代码,在同一个时刻只能做一件事;
    口如果这件事是非常耗时的,就意味着当前的线程就会被阻塞;
所以真正耗时的操作,实际上并不是由JavaScript线程在执行的:
因为js是单线程的，若由js执行则无法执行其他代码
    □浏览器的每个进程是多线程的,那么其他线程可以来完成这个耗时的操作;
    □比如网络请求、定时器,我们只需要在特性的时候执行应该有的回调即可;

如果在执行JavaScript代码的过程中,有异步操作呢?-详见解析图
    □中间我们插入了一个setTimeout的函数调用;
    □这个函数被放到入调用栈中,执行会立即结束,并不会阻塞后续代码的执行;

宏任务和微任务
■但是事件循环中并非只维护着一个队列,事实上是有两个队列:
    □宏任务队列(macrotask queue):ajax、setTimeout、setInterval、DOM监听、UI Rendering等
    □微任务队列(microtask queue):Promise的then回调、Mutation Observer API、queueMicrotask()等
    promise对象中的函数会直接执行/例如:promise(function()).then(),function会直接执行(main script)，执行到resolve后then会放到宏任务队列中
    若在宏任务执行的过程中有微任务产生则会继续之行微任务，执行完微任务之后才会执行宏任务

■那么事件循环对于两个队列的优先级是怎么样的呢?
    □1.main script中的代码优先执行(编写的顶层script代码);
    □2.在执行任何一个宏任务之前(不是队列,是一个宏任务),都会先查看微任务队列中是否有任务需要执行
    √也就是宏任务执行之前,必须保证微任务队列是空的;
√如果不为空,那么就优先执行微任务队列中的任务(回调);
在async异步函数中默认的代码会直接执行，

Node的事件循环,与浏览器的事件循环是相似的
■浏览器中的EventLoop是根据HTML5定义的规范来实现的,不同的浏览器可能会有不同的实现,而Node中是由libuv实现的。
■这里我们来给出一个Node的架构图:
□我们会发现libuv中主要维护了一个EventLoop和worker threads(线程池);
□ EventLoop负责调用系统的一些其他操作:文件的IO、Network、child-processes等
■ libuv是一个多平台的专注于异步IO的库,它最初是为Node开发的,但是现在也被使用到Luvit、Julia、pyuv等其他地方;

Node事件循环的阶段

■我们最前面就强调过,事件循环像是一个桥梁,是连接着应用程序的JavaScript和系统调用之间的通道:
    □无论是我们的文件IO、数据库、网络IO、定时器、子进程,在完成对应的操作后,都会将对应的结果和回调函数放到事件循环(任务队列)中;
    □事件循环会不断的从任务队列中取出对应的事件(回调函数)来执行;

■但是一次完整的事件循环Tick分成很多个阶段: tick是指一次完整的事件循环
□定时器(Timers):本阶段执行已经被setTimeout()和setInterval()的调度回调函数。
□待定回调(Pending Callback):对某些系统操作(如TCP错误类型)执行回调,比如TCP连接时接收到
ECONNREFUSED.
□ idle, prepare:仅系统内部使用。
□轮询(Poll):检索新的I/O事件;执行与I/O相关的回调;
检测(check):setImmediate()回调函数在这里执行。
□关闭的回调函数:一些关闭的回调函数,如:socket.on('close', ... )。

所以,在每一次事件循环的tick中,会按照如下顺序来执行代码:
    next tick microtask queue ;
    other microtask queue ;
    timer queue ;
    poll queue ;
    check queue ;
    close queue ;

Node的宏任务和微任务
    ■我们会发现从一次事件循环的Tick来说,Node的事件循环更复杂,它也分为微任务和宏任务:
    □宏任务(macrotask):setTimeout、setInterval、IO事件、setImmediate、close事件;
    □微任务(microtask):Promise的then回调、process.nextTick、queueMicrotask;
    ■但是,Node中的事件循环不只是 微任务队列和 宏任务队列:
微任务队列:
    V next tick queue : process.nextTick ;
    √other queue:Promise的then回调、queueMicr otask;
□宏任务队列:
    timer queue : setTimeout, setInterval ;
    √poll queue:IO事件;
    V check queue : setImmediate ;
    √close queue:close事件;