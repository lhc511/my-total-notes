1.正则表达式检测查找 test方法和exec方法有什么区别?
    >test方法 用于判断是否有符合规则的字符串,返回的是布尔值 找到返回true,否则false(重点)
    >exec方法用于检索(查找)符合规则的字符串,找到返回数组,否则为null。数组中有相关信息

为了方便记忆和学习，我们对众多的元字符进行了分类：
Ø 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾）
Ø 量词 （表示重复次数）
Ø 字符类 （比如 \d 表示 0~9）

    边界符    说明
    <        表示匹配行首的文本(以谁开始)
    $        表示匹配行尾的文本(以谁结束)
如果 ^ 和 $ 在一起，表示必须是精确匹配。即一模一样
    量词     说明
    *       重复零次或更多次
    +       重复一次或更多次
    ?       重复零次或一次
    {n}     重复n次
    {n,}    重复n次或更多次
    {n,m}   重复n到m次
注意： 逗号左右两侧千万不要出现空格

3. 字符类：
(1) [ ] 匹配字符集合    例如:02-元字符.html
l 后面的字符串只要包含 abc 中任意 一个字符 (只能有一个字符)，都返回 true 。

(1) [ ] 里面加上 - 连字符
l 使用连字符 - 表示一个范围
l 比如：
Ø [a-z] 表示 a 到 z 26个英文字母都可以
Ø [a-zA-Z] 表示大小写都可以
Ø [0-9] 表示 0~9 的数字都可以

3. 字符类：
(1) [ ] 里面加上 ^ 取反符号
l比如：Ø [^a-z] 匹配除了小写字母以外的字符
      Ø 注意要写到中括号里面
（2） . 匹配除换行符之外的任何单个字符

元素.classList.add(类名)追加类名

●(3)预定义:指的是某些常见模式的简写方式。

预定类    说明
\d       匹配0-9之间的任一数字,相当于[0-9]
\D       匹配所有0-9以外的字符,相当于 [^0-9]
\w       匹配任意的字母、数字和下划线,相当于[A-Za-z0-9_]
\W       除所有字母、数字和下划线以外的字符,相当于[^A-Za-z0-9_]
\s       匹配空格(包括换行符、制表符、空格符等),相等于[\t\r\n\w\f]
\S       匹配非空格的字符,相当于[^\t\r\n\v\f]
日期格式:^\d{4}-\d{1,2}-\d{1,2}

input:触发条件：@blur 在输入框失去焦点时触发，无论内容是否发生变化。
      与 @change 的区别：@change 仅在内容发生变化且失去焦点时触发，而 @blur 不依赖内容变化。

reset()   //渲染页面和重置表单

2. 块作用域：
在 JavaScript 中使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。
总结：1. let 声明的变量会产生块作用域，var 不会产生块作用域
     2. const 声明的常量也会产生块作用域
     3. 不同代码块之间的变量无法互相访问

1.4 垃圾回收机制
内存的生命周期
JS环境中分配的内存,一般有如下生命周期:
内存分配:当我们声明变量、函数、对象的时候,系统会自动为他们分配内存
3. 内存回收:使用完毕,由垃圾回收器自动回收不再使用的内存
说明:
> 全局变量一般不会回收(关闭页面回收)
> 一般情况下局部变量的值,不用了,会被自动回收掉
内存使用:即读写内存,也就是使用变量、函数等
内存泄漏:程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏

1.5 闭包
概念:一个函数对周围状态的引用捆绑在一起,内层函数中访问到其外层函数的作用域
简单理解:闭包=内层函数+外层函数的变量
先看个简单的代码:
function outer() {
    const a = 1
    function f() {
        console.log(a)
    f()}
outer()

1.6 变量提升
变量提升是JavaScript中比较“奇怪”的现象,它允许在变量声明之前即被访问(仅存在于var声明变量)
注意:1.变量在未声明即被访问时会报语法错误
    2.变量在var声明之前即被访问,变量的值为 undefined
    3. let/const声明的变量不存在变量提升
    4.变量提升出现在相同作用域当中
    5.实际开发中推荐先声明再访问变量

1.函数提升能够使函数的声明调用更灵活
2.函数表达式不存在提升的现象  只提升前面赋值变量的声明，不提升值
3. 函数提升出现在相同作用域当中

2.剩余参数
剩余参数允许我们将一个不定数量的参数表示为一个数组
function getSum( ... other) {   //other可以是任何名字
    // other 得到[1,2,3]
    console.log(other)}
getSum(1, 2, 3)
1 .... 是语法符号,置于最末函数形参之前,用于获取多余的实参
2. 借助 ... 获取的剩余实参,是个真数组   可以用pop，push等方法   而arguments是一个伪数组用不了

const arr = [1, 5, 3, 8, 2]
console.log( ... arr) // 1 5 3 8 2
说明:1. 不会修改原数组
2.箭头函数参数：普通函数有arguments动态参数
             箭头函数没有arguments 动态参数,但是有 剩余参数 .. args

3.箭头函数 this
在箭头函数出现之前,每一个新函数根据它是被如何调用的来定义这个函数的this值,非常令人讨厌。
箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。

数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。基本语法:
    1. 赋值运算符=左侧的[]用于批量声明变量,右侧数组的单元值将被赋值给左侧的变量
    2. 变量的顺序对应数组单元值的位置依次进行赋值操作
// 普通的数组
const arr = [1, 2, 3]   // 批量声明变量a b c
const [a, b, c] = arr  // 同时将数组单元值 1 2 3 依次赋值给变量a b c
console.log(a) //1
console.log(b) // 2
console.log(c) // 3

对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法。基本语法:
    1. 赋值运算符=左侧的{}用于批量声明变量,右侧对象的属性值将被赋值给左侧的变量
    2. 对象属性的值将被赋值给与属性名相同的变量
    3. 注意解构的变量名不要和外面的变量名冲突否则报错
    4.对象中找不到与变量名一致的属性时变量值为 undefined

● forEach()方法用于调用数组的每个元素,并将元素传递给回调函数。主要使用场景:遍历数组的每个元素
● 语法: 被遍历的数组.forEach(function(当前数组元素,当前元素索引号){//函数体})


filter函数的核心作用
过滤元素：filter遍历数组的每个元素，通过回调函数（通常是箭头函数）对元素进行测试。

返回新数组：只有回调函数返回true的元素才会被包含在新数组中，原始数组保持不变12。

语法格式：
const newArray = array.filter(callback(element, index, array));
callback：测试函数，接收三个可选参数（当前元素element、元素索引index、原始数组array），但通常只使用element。
返回值：一个新数组，包含所有通过测试的元素。
        const arr = [10, 20, 30];          // 原始数组
const newArr = arr.filter(item => item >= 20);  // 应用filter方法
    步骤说明：原始数组：arr 包含三个元素：[10, 20, 30]。
            回调函数：item => item >= 20 是一个箭头函数，它对每个元素进行测试：
            对于 item = 10： 10 >= 20 返回 false，因此被排除。
            对于 item = 20： 20 >= 20 返回 true，因此被保留。
            对于 item = 30： 30 >= 20 返回 true，因此被保留。
            结果：newArr 是一个新数组，只包含满足条件的元素 [20, 30]。
            原数组不变：arr 仍是 [10, 20, 30]，这符合filter不修改原数组的特性

//构造函数创建对象   构造函数名首字母要大写
function Pig(name, age, gender) {
    this.name = name
    this.age = age
    this.gener = gender
}
// 创建佩奇对象
const Peppa =new Pig('佩奇',6,'女’)
// 创建乔治对象
const George= new Pig('乔治',3,'男')
// 创建猪妈妈对象
const Mum =new Pig('猪妈妈',30,'女’)
// 创建猪爸爸对象
const Dad = new Pig('猪爸爸',32,'男')
console.log(Peppa)//{name:'佩奇',age:6,gener:'女'거

说明:1.使用new 关键字调用函数的行为被称为实例化
    2. 实例化构造函数时没有参数时可以省略()
    3. 构造函数内部无需写return,返回值即为新创建的对象
    4. 构造函数内部的return返回的值无效,所以不要写return
    5. new Object ()，new Date()也是实例化构造函数

2.数组常见方法-其他方法
    5.实例方法 join 数组元素拼接为字符串,返回字符串(重点)
    6.实例方法 find 查找元素,返回符合测试条件的第一个数组元素值,如果没有符合条件的则返回undefined(重点)
    7.实例方法 every 检测数组所有元素是否都符合指定条件,如果所有元素都通过检测返回true,否则返回false(重点)
    8.实例方法 some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回true,否则返回false
    9.实例方法 concat 合并两个数组,返回生成新数组
    10.实例方法 sort 对原数组单元值排序
    11.实例方法 splice 删除或替换原数组单元
    12.实例方法 reverse 反转数组
    13.实例方法 findIndex  查找元素的索引值

1.实例属性 length 用来获取字符串的度长(重点)
2.实例方法 split('分隔符')用来将字符串拆分成数组(重点)
3.实例方法 substring(需要截取的第一个字符的索引[,结束的索引号])用于字符串截取(重点)
4.实例方法 startsWith(检测字符串[,检测位置索引号])检测是否以某字符开头(重点)
5.实例方法 includes(搜索的字符串[,检测位置索引号])判断一个字符串是否包含在另一个字符串中,根据情况返回true或false(重点)，区分大小写
6.实例方法 toUpperCase      用于将字母转换成大写
7.实例方法 toLowerCase      用于将就转换成小写
8.实例方法 indexof 检测是否包含某字符
9.实例方法 endswith 检测是否以某字符结尾
10.实例方法 replace 用于替换字符串,支持正则匹配
11.实例方法 match 用于查找字符串,支持正则匹配

1. Js实现面向对象需要借助于谁来实现?  > 构造函数
2. 构造函数存在什么问题?  浪费内存

● 构造函数通过原型分配的函数是所有对象所 共享的。
● JavaScript规定,每一个构造函数都有一个prototype属性,指向另一个对象,所以我们也称为原型对象
● 这个对象可以挂载函数,对象实例化不会多次创建原型上函数,节约内存
● 我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。
● 构造函数和原型对象中的this都指向 实例化的对象

原型对象里面的函数this指向的还是 实例对象
每个函数都有一个 prototype 属性，指向其原型对象。原型对象上的方法和属性可以被所有通过该构造函数创建的实例共享。
被创建对象名 instanceof 构造函数名         //被创建对象是否属于构造函数的对象
function Person() {};   const ldh = new Person()
console.log(ldh instanceof Person)  //ture

// 箭头函数没有this 上一级作用域的this(牢记)
实际应用:  此处可以跳过 动态创建的元素 直接指向模型对象
Modal.prototype.open=function (){
      if (!$('.modal').length){
        $('body').append(this.modalBox)
        $(this.modalBox).find('i').on('click',()=>{
          console.log(this)
          //调用这个对象的关闭函数
          this.close()

1. 拷贝对象:Object.assgin()/展开运算符{ ... obj}拷贝对象，对复杂结构只会拷贝顶级元素
2.拷贝数组:Array.prototype.concat() 或者 [ ... arr]

防抖:单位时间内,频繁触发事件,只执行最后一次
节流:单位时间内,频繁触发事件,只执行一次     即出发后只执行初始代码，后续即便频繁触发 必须等第一次执行完毕后才会执行

1:ontimeupdate 事件在视频/音频(audio/video)当前的播放位置发送改变时触发
2:onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频(audio/video)的下一帧时触发，简单理解为打开视频就触发